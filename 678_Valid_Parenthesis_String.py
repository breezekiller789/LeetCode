#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# https://leetcode.com/problems/valid-parenthesis-string/

# 我的解法比較特殊一點，跟別人的stack,recursion不一樣，我是做兩次線性掃描，一次
# 從頭到尾，一次從尾到頭，每一次掃瞄做的事情基本上都差不多。從頭到尾掃的話，遇到
# (,*就把stack加一，如果遇到)就把stack減一，並且檢查stack有沒有小於零，如果小於
# 零，直接回傳false，因為這不可能是合法的。這樣做完之後，如果stack為零，直接回傳
# True，為什麼我們可以這麼篤定直接回傳，因為如果我掃一次發現stack=0，代表說我
# 左括號和星號的總和右括號的總和一樣，而這就直接代表了我們的星號可以直接當作
# 左括號來用，所以就可以直接回傳True。
# 最後再從尾往頭走一次，這次就變成遇到),*就加一，遇到(就減一，同時檢查stack，小
# 於零就回傳false，走到最後如果跳出來，就可以直接回傳true，再一次，為什麼這樣走
# 出來就可以直接回傳true，因為會跳出來，代表我們stack一定是大於等於零，等於零
# 很直覺可以直接回傳，但是大於零呢？如果大於零，代表我們的右括號跟星號總和大於
# 左括號，但是你回想一下，我們在前面的時候，跳出第一個迴圈，我們的stack一定也是
# 大於零才會走到我們這裡，啊那時候stack大於零，也就代表左括號跟星號總和大於
# 右括號，這個等式兩邊，把星號消掉，就代表我們的左括號跟右括號個數是一樣的，
# 所以可以直接回傳的。

s = "()"        # True
s = "(*)"       # True
# s = "(*))"      # True
# s = "(*)((****))"
# s = "((((()(()()()*()(((((*)()*(**(())))))(())()())(((())())())))))))((((" + \
#     "(())*)))()))(()((*()*(*)))(*)()"
# s = "(((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((" + \
#     "*()()(((()((()*(())*(()**)()(())"
# s = "("
# s = "(((((*)))**"

Stack = 0
for char in s:
    if char == "(" or char == "*":
        Stack += 1
    elif char == ")":
        Stack -= 1
        if Stack < 0:
            print False
            exit()
if Stack == 0:
    print True
    exit()
Stack = 0
for char in s[::-1]:
    if char == ")" or char == "*":
        Stack += 1
    elif char == "(":
        Stack -= 1
        if Stack < 0:
            print False
            exit()
print True
